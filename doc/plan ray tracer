
ğŸ“Œ Algorithme du Ray Tracing dÃ©taillÃ©
1ï¸âƒ£ GÃ©nÃ©ration des Rayons (Ray Casting)

Objectif : Calculer un rayon par pixel qui part de la camÃ©ra vers la scÃ¨ne.
DÃ©finition dâ€™un rayon

Un rayon est dÃ©fini par :

    Origine : la position de la camÃ©ra.

    Direction : un vecteur normalisÃ© pointant vers un pixel de lâ€™Ã©cran.

Structure de base :

typedef struct s_ray {
    t_vector origin;
    t_vector direction;
} t_ray;

Construction du rayon

L'Ã©cran est une grille de pixels et chaque pixel doit avoir un rayon associÃ©.

    DÃ©finir un plan image 2D devant la camÃ©ra.

    Convertir les coordonnÃ©es des pixels en coordonnÃ©es 3D.

    Calculer le vecteur direction du rayon.

Formule pour la direction du rayon :
direction=pixel positionâˆ’camera position
direction=pixel positionâˆ’camera position

Puis normaliser ce vecteur.

ğŸ’¡ Remarque : Pour une camÃ©ra orientable, il faut appliquer une matrice de rotation.
2ï¸âƒ£ Intersection Rayon-Objet

Objectif : Trouver si un rayon touche un objet et Ã  quelle distance.

Chaque objet a une formule mathÃ©matique permettant de tester une intersection avec un rayon.
ğŸ”µ Intersection avec une sphÃ¨re

Ã‰quation dâ€™une sphÃ¨re centrÃ©e en C(xc,yc,zc)C(xcâ€‹,ycâ€‹,zcâ€‹) de rayon RR :
(xâˆ’xc)2+(yâˆ’yc)2+(zâˆ’zc)2=R2
(xâˆ’xcâ€‹)2+(yâˆ’ycâ€‹)2+(zâˆ’zcâ€‹)2=R2

En remplaÃ§ant x,y,zx,y,z par les coordonnÃ©es du rayon :
O+tD
O+tD

On obtient une Ã©quation quadratique :
at2+bt+c=0
at2+bt+c=0

Avec :

    a=Dâ‹…Da=Dâ‹…D (produit scalaire de la direction du rayon)

    b=2Ã—(Oâˆ’C)â‹…Db=2Ã—(Oâˆ’C)â‹…D

    c=(Oâˆ’C)â‹…(Oâˆ’C)âˆ’R2c=(Oâˆ’C)â‹…(Oâˆ’C)âˆ’R2

On rÃ©sout avec le discriminant :
Î”=b2âˆ’4ac
Î”=b2âˆ’4ac

    Si Î”<0Î”<0 â†’ Pas dâ€™intersection.

    Si Î”=0Î”=0 â†’ Une seule intersection.

    Si Î”>0Î”>0 â†’ Deux intersections (prendre la plus proche tt > 0).

ğŸ’¡ Remarque : Pour dâ€™autres objets (plans, cylindres), des formules similaires existent.
3ï¸âƒ£ DÃ©termination de la Couleur du Pixel

Objectif : Calculer lâ€™illumination dâ€™un point touchÃ© par un rayon.
LumiÃ¨re ambiante
I=kaÃ—Ia
I=kaâ€‹Ã—Iaâ€‹

    IaIaâ€‹ : intensitÃ© de la lumiÃ¨re ambiante.

    kakaâ€‹ : coefficient de rÃ©flexion ambiante (propre Ã  lâ€™objet).

LumiÃ¨re diffuse (Lambert)
I=kdÃ—IlÃ—maxâ¡(0,Nâ‹…L)
I=kdâ€‹Ã—Ilâ€‹Ã—max(0,Nâ‹…L)

    kdkdâ€‹ : coefficient de diffusion.

    IlIlâ€‹ : intensitÃ© de la lumiÃ¨re.

    NN : normale de la surface.

    LL : direction de la lumiÃ¨re.

    Nâ‹…LNâ‹…L : produit scalaire (plus lâ€™angle est petit, plus la lumiÃ¨re est forte).

LumiÃ¨re spÃ©culaire (Phong)
I=ksÃ—IlÃ—(maxâ¡(0,Râ‹…V))n
I=ksâ€‹Ã—Ilâ€‹Ã—(max(0,Râ‹…V))n

    ksksâ€‹ : coefficient spÃ©culaire.

    RR : rayon rÃ©flÃ©chi.

    VV : direction de la camÃ©ra.

    nn : facteur de brillance (plus il est Ã©levÃ©, plus le reflet est net).

ğŸ’¡ Remarque : Somme de ces trois composantes donne la couleur finale.
4ï¸âƒ£ Gestion des Ombres

Objectif : VÃ©rifier si un point est Ã©clairÃ© ou dans lâ€™ombre.

    Lancer un rayon dâ€™ombre depuis le point touchÃ© vers la lumiÃ¨re.

    Si ce rayon rencontre un objet avant la lumiÃ¨re, le point est dans lâ€™ombre.

5ï¸âƒ£ Gestion des RÃ©flexions et Transparence (Bonus)
RÃ©flexions (Rayon rebondissant)

Si un objet est rÃ©flÃ©chissant, il faut calculer un nouveau rayon :
R=Dâˆ’2(Dâ‹…N)N
R=Dâˆ’2(Dâ‹…N)N

    RR : direction du rayon rÃ©flÃ©chi.

    DD : direction du rayon incident.

    NN : normale de la surface.

RÃ©fraction (Objets transparents)
T=Î·1/Î·2Ã—(Dâˆ’(Dâ‹…N)N)âˆ’N1âˆ’(Î·1/Î·2)2(1âˆ’(Dâ‹…N)2)
T=Î·1â€‹/Î·2â€‹Ã—(Dâˆ’(Dâ‹…N)N)âˆ’N1âˆ’(Î·1â€‹/Î·2â€‹)2(1âˆ’(Dâ‹…N)2)
â€‹

    Î·1,Î·2Î·1â€‹,Î·2â€‹ : indices de rÃ©fraction des milieux.

ğŸ’¡ Remarque : Ce sont des calculs lourds, Ã  implÃ©menter en bonus.
ğŸ›  ImplÃ©mentation : Code de Base
CrÃ©er et lancer un rayon

t_ray generate_ray(t_camera *cam, int x, int y, int width, int height) {
    t_ray ray;
    float px = (2.0f * x / width - 1) * aspect_ratio;
    float py = (1 - 2.0f * y / height);
    
    ray.origin = cam->position;
    ray.direction = normalize(vector(px, py, -1));
    return ray;
}

Intersection Rayon-SphÃ¨re

int intersect_sphere(t_ray ray, t_sphere sphere, float *t) {
    t_vector oc = subtract(ray.origin, sphere.center);
    float a = dot(ray.direction, ray.direction);
    float b = 2.0f * dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float delta = b * b - 4 * a * c;

    if (delta < 0)
        return (0);
    *t = (-b - sqrt(delta)) / (2.0 * a);
    return (1);
}

ğŸ“Œ Plan de dÃ©veloppement
Ã‰tape	Description	DurÃ©e estimÃ©e
ğŸ¯ GÃ©nÃ©ration des rayons	Calcul des directions	1 jour
ğŸ”µ Intersection sphÃ¨re	DÃ©tection de collisions	2 jours
ğŸ’¡ LumiÃ¨res & Ombres	ModÃ¨le de Phong	3 jours
ğŸª RÃ©flexions	Rayon rebondissant	2 jours (Bonus)
ğŸ”® RÃ©fraction	Effet de verre	3 jours (Bonus)
ğŸš€ Conclusion

Avec cette approche, tu peux avancer progressivement vers un rendu rÃ©aliste ! Commence simple (sphÃ¨re + lumiÃ¨re) puis ajoute les ombres et effets avancÃ©s.

Si tu veux plus de dÃ©tails sur une partie, dis-moi ! ğŸ˜ƒğŸ”¥


#include "minirt.h"  // Fichier contenant les structures t_vector, t_ray, etc.
#include <math.h>

t_ray generate_ray(t_camera *cam, int x, int y, int width, int height) {
    t_ray ray;
    float aspect_ratio = (float)width / (float)height;
    float scale = tan((cam->fov * 0.5) * (M_PI / 180.0));  // Conversion FOV en radians

    // Transformation des coordonnÃ©es de pixel en espace 3D
    float px = (2.0f * x / width - 1.0f) * aspect_ratio * scale;
    float py = (1.0f - 2.0f * y / height) * scale;

    // Calcul de la direction du rayon avec la base orthonormÃ©e de la camÃ©ra
    t_vector direction = normalize(vector_add(
        vector_add(vector_multiply(cam->right, px), 
                   vector_multiply(cam->up, py)),
        cam->forward
    ));

    // Construction du rayon
    ray.origin = cam->position;
    ray.direction = direction;

    return ray;
}
